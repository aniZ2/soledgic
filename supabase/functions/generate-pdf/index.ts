// Soledgic Edge Function: Generate PDF Reports
// POST /generate-pdf - Creates downloadable PDF reports
// SECURITY HARDENED VERSION v2 - Fixed auth bypass and rate limiting

import { 
  createHandler,
  getCorsHeaders, 
  getSupabaseClient, 
  validateApiKey, 
  jsonResponse, 
  errorResponse, 
  validateId,
  checkRateLimit,
  getClientIp,
  LedgerContext
} from '../_shared/utils.ts'
import { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'

type ReportType = 'creator_statement' | 'profit_loss' | 'balance_sheet' | 'trial_balance' | '1099' | 'reconciliation_summary'

interface PDFRequest { 
  report_type: ReportType
  period_id?: string
  creator_id?: string
  start_date?: string
  end_date?: string
  tax_year?: number
  ledger_id?: string 
}

interface PDFContent { 
  title: string
  subtitle?: string
  businessName: string
  period?: string
  sections: Array<{ title: string; rows: Array<{ label: string; amount: string; isTotal?: boolean }> }>
  integrityHash?: string 
}

function escapePDF(str: string): string { 
  return str.replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)') 
}

function generatePDF(content: PDFContent): string {
  const lineHeight = 14, pageWidth = 612, leftMargin = 50, rightMargin = pageWidth - 50
  let yPos = 750, contentStream = 'BT\n'
  
  contentStream += `/F1 18 Tf\n${leftMargin} ${yPos} Td\n(${escapePDF(content.title)}) Tj\n`; yPos -= 30
  if (content.subtitle) { contentStream += `/F1 10 Tf\n0 -20 Td\n(${escapePDF(content.subtitle)}) Tj\n`; yPos -= 20 }
  contentStream += `/F1 12 Tf\n0 -25 Td\n(${escapePDF(content.businessName)}) Tj\n`; yPos -= 40
  if (content.period) { contentStream += `/F1 10 Tf\n0 -15 Td\n(Period: ${escapePDF(content.period)}) Tj\n`; yPos -= 20 }
  contentStream += 'ET\nq\n0.5 w\n'; contentStream += `${leftMargin} ${yPos} m ${rightMargin} ${yPos} l S\nQ\nBT\n`; yPos -= 30

  for (const section of content.sections) {
    contentStream += `/F1 12 Tf\n${leftMargin} ${yPos} Td\n(${escapePDF(section.title)}) Tj\n`; yPos -= 20
    contentStream += `/F1 10 Tf\n`
    for (const row of section.rows) {
      contentStream += `0 -${lineHeight} Td\n`
      const prefix = row.isTotal ? '' : '  '
      contentStream += `(${prefix}${escapePDF(row.label)}) Tj\n`
      const amountWidth = row.amount.length * 6
      contentStream += `${rightMargin - leftMargin - amountWidth - 60} 0 Td\n(${escapePDF(row.amount)}) Tj\n`
      contentStream += `${-(rightMargin - leftMargin - amountWidth - 60)} 0 Td\n`
      yPos -= lineHeight
    }
    yPos -= 15
  }

  yPos = 50; contentStream += `/F1 8 Tf\n${leftMargin} ${yPos} Td\n(Generated by Soledgic | ${new Date().toISOString().split('T')[0]}) Tj\n`
  if (content.integrityHash) contentStream += `0 -12 Td\n(Integrity Hash: ${content.integrityHash.slice(0, 32)}...) Tj\n`
  contentStream += 'ET'

  const objects = [
    `1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj`,
    `2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj`,
    `3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>\nendobj`,
    `4 0 obj\n<< /Length ${contentStream.length} >>\nstream\n${contentStream}\nendstream\nendobj`,
    `5 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\nendobj`
  ]

  let pdf = '%PDF-1.4\n'; const xrefOffsets: number[] = []
  for (const obj of objects) { xrefOffsets.push(pdf.length); pdf += obj + '\n' }
  const xrefStart = pdf.length
  pdf += 'xref\n'; pdf += `0 ${objects.length + 1}\n`; pdf += '0000000000 65535 f \n'
  for (const offset of xrefOffsets) pdf += offset.toString().padStart(10, '0') + ' 00000 n \n'
  pdf += 'trailer\n'; pdf += `<< /Size ${objects.length + 1} /Root 1 0 R >>\n`; pdf += 'startxref\n'; pdf += xrefStart + '\n'; pdf += '%%EOF'
  return btoa(pdf)
}

const VALID_REPORT_TYPES = ['creator_statement', 'profit_loss', 'balance_sheet', 'trial_balance', '1099', 'reconciliation_summary']

// ============================================================================
// SECURITY FIX: Validate internal service calls properly
// ============================================================================
function isValidInternalCall(authHeader: string | null): boolean {
  if (!authHeader) return false
  
  const serviceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')
  
  // CRITICAL: Fail-closed if service key is not configured
  if (!serviceKey || serviceKey.length < 20) {
    console.error('SECURITY: SUPABASE_SERVICE_ROLE_KEY not configured or too short')
    return false
  }
  
  // Extract Bearer token and compare directly (not includes!)
  const token = authHeader.replace('Bearer ', '').trim()
  
  // Constant-time comparison to prevent timing attacks
  if (token.length !== serviceKey.length) return false
  
  let result = 0
  for (let i = 0; i < token.length; i++) {
    result |= token.charCodeAt(i) ^ serviceKey.charCodeAt(i)
  }
  
  return result === 0
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') return new Response('ok', { headers: getCorsHeaders(req) })

  const clientIp = getClientIp(req)

  try {
    const apiKey = req.headers.get('x-api-key')
    const authHeader = req.headers.get('authorization')
    const supabase = getSupabaseClient()
    
    let ledgerId: string | null = null
    let ledger: LedgerContext | null = null
    let isInternalCall = false

    // ========================================================================
    // AUTHENTICATION (SECURITY HARDENED)
    // ========================================================================
    
    if (apiKey) {
      // External API call - validate API key first
      ledger = await validateApiKey(supabase, apiKey)
      if (!ledger) {
        return errorResponse('Invalid API key', 401, req)
      }
      
      // SECURITY FIX: Rate limit by LEDGER ID, not API key
      // This prevents bypass via key rotation
      const { allowed, resetIn } = await checkRateLimit(ledger.id, 'generate-pdf', supabase)
      if (!allowed) {
        return new Response(
          JSON.stringify({ success: false, error: 'Rate limit exceeded' }),
          { status: 429, headers: { ...getCorsHeaders(req), 'Content-Type': 'application/json', 'Retry-After': String(resetIn || 60) } }
        )
      }
      
      ledgerId = ledger.id
      
    } else if (isValidInternalCall(authHeader)) {
      // Internal service call - validated with proper comparison
      isInternalCall = true
      
      // SECURITY FIX: Rate limit internal calls by IP to prevent abuse
      const { allowed, resetIn } = await checkRateLimit(`internal:${clientIp}`, 'generate-pdf', supabase)
      if (!allowed) {
        return new Response(
          JSON.stringify({ success: false, error: 'Rate limit exceeded' }),
          { status: 429, headers: { ...getCorsHeaders(req), 'Content-Type': 'application/json', 'Retry-After': String(resetIn || 60) } }
        )
      }
      
    } else {
      // No valid auth - reject
      return errorResponse('Authentication required', 401, req)
    }

    const body: PDFRequest = await req.json()
    
    // For internal calls, ledger_id must be provided in body
    if (isInternalCall) {
      if (!body.ledger_id) {
        return errorResponse('ledger_id required for internal calls', 400, req)
      }
      ledgerId = validateId(body.ledger_id, 100)
    }
    
    if (!ledgerId) {
      return errorResponse('ledger_id required', 400, req)
    }

    if (!body.report_type || !VALID_REPORT_TYPES.includes(body.report_type)) {
      return errorResponse(`Invalid report_type: must be one of ${VALID_REPORT_TYPES.join(', ')}`, 400, req)
    }

    const { data: ledgerData } = await supabase.from('ledgers').select('id, business_name').eq('id', ledgerId).single()
    if (!ledgerData) return errorResponse('Ledger not found', 404, req)

    const formatCurrency = (n: number) => `$${n.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',')}`
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/

    switch (body.report_type) {
      case 'creator_statement': {
        const creatorId = body.creator_id ? validateId(body.creator_id, 100) : null
        if (!creatorId) return errorResponse('Invalid creator_id', 400, req)

        const startDate = body.start_date && dateRegex.test(body.start_date) ? body.start_date : new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString().split('T')[0]
        const endDate = body.end_date && dateRegex.test(body.end_date) ? body.end_date : new Date().toISOString().split('T')[0]

        const { data: creator } = await supabase.from('accounts').select('id, name, entity_id, metadata').eq('ledger_id', ledgerId).eq('account_type', 'creator_balance').eq('entity_id', creatorId).single()
        if (!creator) return errorResponse('Creator not found', 404, req)

        const { data: entries } = await supabase.from('entries').select('entry_type, amount, transactions!inner(id, description, created_at, transaction_type, status)').eq('account_id', creator.id).not('transactions.status', 'in', '("voided","reversed")').gte('transactions.created_at', startDate).lte('transactions.created_at', endDate + 'T23:59:59')

        let totalEarnings = 0, totalPayouts = 0
        const earningsRows: Array<{ label: string; amount: string }> = [], payoutRows: Array<{ label: string; amount: string }> = []

        for (const entry of entries || []) {
          const tx = (entry as any).transactions, amount = Number(entry.amount), date = new Date(tx.created_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
          if (entry.entry_type === 'credit') { totalEarnings += amount; earningsRows.push({ label: `${date} - ${tx.description || 'Sale'}`, amount: formatCurrency(amount) }) }
          else { totalPayouts += amount; payoutRows.push({ label: `${date} - ${tx.description || 'Payout'}`, amount: formatCurrency(amount) }) }
        }

        const pdfContent: PDFContent = { title: 'Creator Earnings Statement', subtitle: creator.name, businessName: ledgerData.business_name || 'Soledgic', period: `${startDate} to ${endDate}`,
          sections: [
            { title: 'EARNINGS', rows: [...earningsRows.slice(0, 15), { label: 'Total Earnings', amount: formatCurrency(totalEarnings), isTotal: true }] },
            { title: 'PAYOUTS', rows: [...payoutRows.slice(0, 10), { label: 'Total Payouts', amount: formatCurrency(totalPayouts), isTotal: true }] },
            { title: 'SUMMARY', rows: [{ label: 'Earnings This Period', amount: formatCurrency(totalEarnings) }, { label: 'Payouts This Period', amount: `(${formatCurrency(totalPayouts)})` }, { label: 'Net Balance', amount: formatCurrency(totalEarnings - totalPayouts), isTotal: true }] }
          ]
        }

        return jsonResponse({ success: true, filename: `statement_${creatorId}_${startDate}_${endDate}.pdf`, content_type: 'application/pdf', data: generatePDF(pdfContent) }, 200, req)
      }

      case 'profit_loss': {
        const startDate = body.start_date && dateRegex.test(body.start_date) ? body.start_date : new Date(new Date().getFullYear(), 0, 1).toISOString().split('T')[0]
        const endDate = body.end_date && dateRegex.test(body.end_date) ? body.end_date : new Date().toISOString().split('T')[0]

        const { data: accounts } = await supabase.from('accounts').select('id, name, account_type').eq('ledger_id', ledgerId).in('account_type', ['revenue', 'platform_revenue', 'other_income', 'expense', 'processing_fees', 'cost_of_goods'])

        const revenueItems: Array<{ label: string; amount: string }> = [], expenseItems: Array<{ label: string; amount: string }> = []
        let totalRevenue = 0, totalExpenses = 0

        for (const account of accounts || []) {
          const { data: entries } = await supabase.from('entries').select('entry_type, amount, transactions!inner(created_at, status)').eq('account_id', account.id).not('transactions.status', 'in', '("voided","reversed")').gte('transactions.created_at', startDate).lte('transactions.created_at', endDate + 'T23:59:59')

          let balance = 0
          for (const e of entries || []) balance += e.entry_type === 'credit' ? Number(e.amount) : -Number(e.amount)
          balance = Math.abs(balance)

          if (balance > 0) {
            if (['revenue', 'platform_revenue', 'other_income'].includes(account.account_type)) { revenueItems.push({ label: account.name, amount: formatCurrency(balance) }); totalRevenue += balance }
            else { expenseItems.push({ label: account.name, amount: formatCurrency(balance) }); totalExpenses += balance }
          }
        }

        const pdfContent: PDFContent = { title: 'Profit & Loss Statement', businessName: ledgerData.business_name || 'Soledgic', period: `${startDate} to ${endDate}`,
          sections: [
            { title: 'REVENUE', rows: [...revenueItems, { label: 'Total Revenue', amount: formatCurrency(totalRevenue), isTotal: true }] },
            { title: 'EXPENSES', rows: [...expenseItems, { label: 'Total Expenses', amount: formatCurrency(totalExpenses), isTotal: true }] },
            { title: 'NET INCOME', rows: [{ label: 'Net Income', amount: formatCurrency(totalRevenue - totalExpenses), isTotal: true }] }
          ]
        }

        return jsonResponse({ success: true, filename: `pl_${startDate}_${endDate}.pdf`, content_type: 'application/pdf', data: generatePDF(pdfContent) }, 200, req)
      }

      case 'trial_balance': {
        const { data: accounts } = await supabase.from('accounts').select('id, name, account_type').eq('ledger_id', ledgerId).eq('is_active', true)

        const rows: Array<{ label: string; amount: string; isTotal?: boolean }> = []
        let totalDebits = 0, totalCredits = 0

        for (const account of accounts || []) {
          const { data: entries } = await supabase.from('entries').select('entry_type, amount, transactions!inner(status)').eq('account_id', account.id).not('transactions.status', 'in', '("voided","reversed")')

          let debits = 0, credits = 0
          for (const e of entries || []) { if (e.entry_type === 'debit') debits += Number(e.amount); else credits += Number(e.amount) }

          if (debits > 0 || credits > 0) {
            const netDebit = debits > credits ? debits - credits : 0, netCredit = credits > debits ? credits - debits : 0
            rows.push({ label: account.name, amount: netDebit > 0 ? `DR ${formatCurrency(netDebit)}` : `CR ${formatCurrency(netCredit)}` })
            totalDebits += netDebit; totalCredits += netCredit
          }
        }

        const pdfContent: PDFContent = { title: 'Trial Balance', businessName: ledgerData.business_name || 'Soledgic', period: `As of ${new Date().toISOString().split('T')[0]}`,
          sections: [{ title: 'ACCOUNTS', rows: [...rows, { label: 'Total Debits', amount: formatCurrency(totalDebits), isTotal: true }, { label: 'Total Credits', amount: formatCurrency(totalCredits), isTotal: true }] }]
        }

        return jsonResponse({ success: true, filename: `trial_balance_${new Date().toISOString().split('T')[0]}.pdf`, content_type: 'application/pdf', data: generatePDF(pdfContent) }, 200, req)
      }

      case '1099': {
        const year = body.tax_year && body.tax_year >= 2020 && body.tax_year <= 2100 ? body.tax_year : new Date().getFullYear()
        const { data: creators } = await supabase.from('accounts').select('id, entity_id, name').eq('ledger_id', ledgerId).eq('account_type', 'creator_balance')

        const rows: Array<{ label: string; amount: string }> = []
        let totalPaid = 0, requiring1099 = 0

        for (const creator of creators || []) {
          const { data: payoutEntries } = await supabase.from('entries').select('amount, transactions!inner(created_at, transaction_type, status)').eq('account_id', creator.id).eq('entry_type', 'debit').eq('transactions.transaction_type', 'payout').gte('transactions.created_at', `${year}-01-01`).lte('transactions.created_at', `${year}-12-31T23:59:59`).not('transactions.status', 'in', '("voided","reversed")')

          let paid = 0
          for (const e of payoutEntries || []) paid += Number(e.amount)
          if (paid > 0) { if (paid >= 600) requiring1099++; totalPaid += paid; rows.push({ label: `${creator.name}${paid >= 600 ? ' *' : ''}`, amount: formatCurrency(paid) }) }
        }

        const pdfContent: PDFContent = { title: `1099-NEC Summary - Tax Year ${year}`, subtitle: '* Indicates 1099 required (>= $600)', businessName: ledgerData.business_name || 'Soledgic',
          sections: [{ title: 'PAYEES', rows: [...rows, { label: 'Total Paid', amount: formatCurrency(totalPaid), isTotal: true }, { label: '1099s Required', amount: requiring1099.toString(), isTotal: true }] }]
        }

        return jsonResponse({ success: true, filename: `1099_summary_${year}.pdf`, content_type: 'application/pdf', data: generatePDF(pdfContent) }, 200, req)
      }

      default:
        return errorResponse(`Unknown report type: ${body.report_type}`, 400, req)
    }
  } catch (error: any) {
    console.error('PDF generation error:', error)
    return errorResponse('Internal server error', 500, req)
  }
})
