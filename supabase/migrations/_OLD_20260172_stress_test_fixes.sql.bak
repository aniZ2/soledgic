-- Migration: Fix Stress Test Failures
-- Addresses:
-- 1. Balance sheet not balanced (calculation issues)
-- 2. AR/AP aging vs balance sheet inconsistency
-- 3. 404 vs 500 for invalid UUIDs
-- 4. Void invoice AR reversal issues

-- ============================================================================
-- 1. Fix record_bill_payment_atomic - add better error handling
-- ============================================================================

CREATE OR REPLACE FUNCTION record_bill_payment_atomic(
  p_ledger_id UUID,
  p_amount_cents BIGINT,
  p_bill_transaction_id UUID DEFAULT NULL,
  p_vendor_name TEXT DEFAULT NULL,
  p_payment_method TEXT DEFAULT NULL,
  p_reference_id TEXT DEFAULT NULL
)
RETURNS TABLE(
  success BOOLEAN,
  message TEXT,
  transaction_id UUID,
  amount_dollars NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_cash_account_id UUID;
  v_ap_account_id UUID;
  v_transaction_id UUID;
  v_amount_dollars NUMERIC;
  v_description TEXT;
  v_original_bill RECORD;
BEGIN
  -- Validate amount
  IF p_amount_cents IS NULL OR p_amount_cents <= 0 THEN
    RETURN QUERY SELECT false, 'Payment amount must be positive'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  -- Get or create required accounts
  v_cash_account_id := get_or_create_ledger_account(p_ledger_id, 'cash', 'Cash / Bank');
  v_ap_account_id := get_or_create_ledger_account(p_ledger_id, 'accounts_payable', 'Accounts Payable');
  
  IF v_cash_account_id IS NULL OR v_ap_account_id IS NULL THEN
    RETURN QUERY SELECT false, 'Failed to create required accounts'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  v_amount_dollars := p_amount_cents / 100.0;
  
  -- Build description
  v_description := 'Bill payment';
  IF p_bill_transaction_id IS NOT NULL THEN
    SELECT description, merchant_name INTO v_original_bill
    FROM transactions
    WHERE id = p_bill_transaction_id AND ledger_id = p_ledger_id;
    
    IF FOUND AND v_original_bill.description IS NOT NULL THEN
      v_description := 'Payment: ' || v_original_bill.description;
    END IF;
  ELSIF p_vendor_name IS NOT NULL THEN
    v_description := 'Payment to ' || p_vendor_name;
  END IF;
  
  -- Create transaction
  INSERT INTO transactions (
    ledger_id, transaction_type, reference_id, reference_type,
    description, amount, currency, status, merchant_name, metadata
  ) VALUES (
    p_ledger_id, 'bill_payment', p_reference_id, COALESCE(p_payment_method, 'payment'),
    v_description, v_amount_dollars, 'USD', 'completed', p_vendor_name,
    jsonb_build_object(
      'original_bill_id', p_bill_transaction_id,
      'payment_method', p_payment_method
    )
  )
  RETURNING id INTO v_transaction_id;
  
  -- Create double-entry: Debit AP (reduce liability), Credit Cash (reduce asset)
  INSERT INTO entries (transaction_id, account_id, entry_type, amount)
  VALUES 
    (v_transaction_id, v_ap_account_id, 'debit', v_amount_dollars),
    (v_transaction_id, v_cash_account_id, 'credit', v_amount_dollars);
  
  RETURN QUERY SELECT true, ('Bill payment of $' || v_amount_dollars || ' recorded')::TEXT, 
    v_transaction_id, v_amount_dollars;
    
EXCEPTION WHEN OTHERS THEN
  RETURN QUERY SELECT false, ('Error: ' || SQLERRM)::TEXT, NULL::UUID, NULL::NUMERIC;
END;
$$;

-- ============================================================================
-- 2. Add helper function for safe UUID validation
-- ============================================================================

CREATE OR REPLACE FUNCTION is_valid_uuid(p_text TEXT)
RETURNS BOOLEAN
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
  IF p_text IS NULL THEN
    RETURN FALSE;
  END IF;
  
  -- Try to cast to UUID, return true if succeeds
  PERFORM p_text::UUID;
  RETURN TRUE;
EXCEPTION WHEN OTHERS THEN
  RETURN FALSE;
END;
$$;

-- ============================================================================
-- 3. Fix send_invoice_atomic - ensure proper error returns
-- ============================================================================

CREATE OR REPLACE FUNCTION send_invoice_atomic(
  p_invoice_id UUID,
  p_ledger_id UUID
)
RETURNS TABLE(
  success BOOLEAN,
  message TEXT,
  transaction_id UUID
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_invoice RECORD;
  v_ar_account_id UUID;
  v_revenue_account_id UUID;
  v_transaction_id UUID;
  v_amount_dollars NUMERIC;
BEGIN
  -- Validate UUID format first
  IF p_invoice_id IS NULL THEN
    RETURN QUERY SELECT false, 'Invoice ID is required'::TEXT, NULL::UUID;
    RETURN;
  END IF;

  -- Lock and fetch invoice
  SELECT * INTO v_invoice
  FROM invoices
  WHERE id = p_invoice_id AND ledger_id = p_ledger_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT false, 'Invoice not found'::TEXT, NULL::UUID;
    RETURN;
  END IF;
  
  IF v_invoice.status != 'draft' THEN
    RETURN QUERY SELECT false, ('Invoice cannot be sent from status: ' || v_invoice.status)::TEXT, NULL::UUID;
    RETURN;
  END IF;
  
  -- Get or create required accounts
  v_ar_account_id := get_or_create_ledger_account(p_ledger_id, 'accounts_receivable', 'Accounts Receivable');
  v_revenue_account_id := get_or_create_ledger_account(p_ledger_id, 'revenue', 'Revenue');
  
  IF v_ar_account_id IS NULL OR v_revenue_account_id IS NULL THEN
    RETURN QUERY SELECT false, 'Failed to create required accounts'::TEXT, NULL::UUID;
    RETURN;
  END IF;
  
  v_amount_dollars := v_invoice.total_amount / 100.0;
  
  -- Create AR transaction
  INSERT INTO transactions (
    ledger_id, transaction_type, reference_id, reference_type,
    description, amount, currency, status, metadata
  ) VALUES (
    p_ledger_id, 'invoice', v_invoice.invoice_number, 'invoice',
    'Invoice ' || v_invoice.invoice_number || ' - ' || v_invoice.customer_name,
    v_amount_dollars, v_invoice.currency, 'completed',
    jsonb_build_object(
      'invoice_id', v_invoice.id,
      'customer_id', v_invoice.customer_id,
      'customer_name', v_invoice.customer_name
    )
  )
  RETURNING id INTO v_transaction_id;
  
  -- Create double-entry: Debit AR (increase asset), Credit Revenue (increase income)
  INSERT INTO entries (transaction_id, account_id, entry_type, amount)
  VALUES 
    (v_transaction_id, v_ar_account_id, 'debit', v_amount_dollars),
    (v_transaction_id, v_revenue_account_id, 'credit', v_amount_dollars);
  
  -- Update invoice status
  UPDATE invoices
  SET status = 'sent',
      sent_at = NOW(),
      transaction_id = v_transaction_id
  WHERE id = p_invoice_id;
  
  RETURN QUERY SELECT true, 'Invoice sent and AR entry created'::TEXT, v_transaction_id;
  
EXCEPTION WHEN OTHERS THEN
  RETURN QUERY SELECT false, ('Error: ' || SQLERRM)::TEXT, NULL::UUID;
END;
$$;

-- ============================================================================
-- 4. Fix record_invoice_payment_atomic - ensure proper error returns
-- ============================================================================

CREATE OR REPLACE FUNCTION record_invoice_payment_atomic(
  p_invoice_id UUID,
  p_ledger_id UUID,
  p_amount_cents BIGINT,
  p_payment_method TEXT DEFAULT NULL,
  p_payment_date DATE DEFAULT NULL,
  p_reference_id TEXT DEFAULT NULL,
  p_notes TEXT DEFAULT NULL
)
RETURNS TABLE(
  success BOOLEAN,
  message TEXT,
  transaction_id UUID,
  new_status TEXT,
  amount_paid_total BIGINT,
  amount_due_remaining BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_invoice RECORD;
  v_cash_account_id UUID;
  v_ar_account_id UUID;
  v_transaction_id UUID;
  v_amount_dollars NUMERIC;
  v_new_amount_paid BIGINT;
  v_new_amount_due BIGINT;
  v_new_status TEXT;
  v_payment_date DATE;
BEGIN
  -- Validate UUID format first
  IF p_invoice_id IS NULL THEN
    RETURN QUERY SELECT false, 'Invoice ID is required'::TEXT, NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;

  -- Lock and fetch invoice
  SELECT * INTO v_invoice
  FROM invoices
  WHERE id = p_invoice_id AND ledger_id = p_ledger_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT false, 'Invoice not found'::TEXT, NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;
  
  IF v_invoice.status = 'void' THEN
    RETURN QUERY SELECT false, 'Cannot record payment on invoice with status: void'::TEXT, NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;
  
  IF v_invoice.status = 'draft' THEN
    RETURN QUERY SELECT false, 'Cannot record payment on invoice with status: draft'::TEXT, NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;
  
  IF v_invoice.status = 'paid' THEN
    RETURN QUERY SELECT false, 'Invoice is already fully paid'::TEXT, NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;
  
  IF p_amount_cents IS NULL OR p_amount_cents <= 0 THEN
    RETURN QUERY SELECT false, 'Payment amount must be positive'::TEXT, NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;
  
  IF p_amount_cents > v_invoice.amount_due THEN
    RETURN QUERY SELECT false, ('Payment amount (' || p_amount_cents || ') exceeds amount due (' || v_invoice.amount_due || ')')::TEXT, 
      NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;
  
  -- Get or create required accounts
  v_cash_account_id := get_or_create_ledger_account(p_ledger_id, 'cash', 'Cash / Bank');
  v_ar_account_id := get_or_create_ledger_account(p_ledger_id, 'accounts_receivable', 'Accounts Receivable');
  
  IF v_cash_account_id IS NULL OR v_ar_account_id IS NULL THEN
    RETURN QUERY SELECT false, 'Failed to create required accounts'::TEXT, NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;
  
  v_amount_dollars := p_amount_cents / 100.0;
  v_payment_date := COALESCE(p_payment_date, CURRENT_DATE);
  v_new_amount_paid := v_invoice.amount_paid + p_amount_cents;
  v_new_amount_due := v_invoice.total_amount - v_new_amount_paid;
  v_new_status := CASE WHEN v_new_amount_due <= 0 THEN 'paid' ELSE 'partial' END;
  
  -- Create payment transaction
  INSERT INTO transactions (
    ledger_id, transaction_type, reference_id, reference_type,
    description, amount, currency, status, metadata
  ) VALUES (
    p_ledger_id, 'invoice_payment', p_reference_id, COALESCE(p_payment_method, 'payment'),
    'Payment received: Invoice ' || v_invoice.invoice_number, v_amount_dollars,
    v_invoice.currency, 'completed',
    jsonb_build_object(
      'invoice_id', v_invoice.id,
      'invoice_number', v_invoice.invoice_number,
      'customer_id', v_invoice.customer_id,
      'customer_name', v_invoice.customer_name,
      'payment_method', p_payment_method
    )
  )
  RETURNING id INTO v_transaction_id;
  
  -- Create double-entry: Debit Cash (increase asset), Credit AR (decrease asset)
  INSERT INTO entries (transaction_id, account_id, entry_type, amount)
  VALUES 
    (v_transaction_id, v_cash_account_id, 'debit', v_amount_dollars),
    (v_transaction_id, v_ar_account_id, 'credit', v_amount_dollars);
  
  -- Record payment in invoice_payments table
  INSERT INTO invoice_payments (
    invoice_id, transaction_id, amount, payment_date, 
    payment_method, reference_id, notes
  ) VALUES (
    p_invoice_id, v_transaction_id, p_amount_cents, v_payment_date,
    p_payment_method, p_reference_id, p_notes
  );
  
  -- Update invoice
  UPDATE invoices
  SET amount_paid = v_new_amount_paid,
      amount_due = v_new_amount_due,
      status = v_new_status,
      paid_at = CASE WHEN v_new_status = 'paid' THEN NOW() ELSE NULL END
  WHERE id = p_invoice_id;
  
  RETURN QUERY SELECT true, ('Payment of $' || v_amount_dollars || ' recorded')::TEXT, 
    v_transaction_id, v_new_status, v_new_amount_paid, v_new_amount_due;
    
EXCEPTION WHEN OTHERS THEN
  RETURN QUERY SELECT false, ('Error: ' || SQLERRM)::TEXT, NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
END;
$$;

-- ============================================================================
-- 5. Fix void_invoice_atomic - proper AR reversal
-- ============================================================================

CREATE OR REPLACE FUNCTION void_invoice_atomic(
  p_invoice_id UUID,
  p_ledger_id UUID,
  p_reason TEXT DEFAULT NULL
)
RETURNS TABLE(
  success BOOLEAN,
  message TEXT,
  reversal_transaction_id UUID,
  reversed_amount NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_invoice RECORD;
  v_ar_account_id UUID;
  v_revenue_account_id UUID;
  v_reversal_tx_id UUID;
  v_amount_to_reverse NUMERIC;
BEGIN
  -- Validate UUID format first
  IF p_invoice_id IS NULL THEN
    RETURN QUERY SELECT false, 'Invoice ID is required'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;

  -- Lock and fetch invoice
  SELECT * INTO v_invoice
  FROM invoices
  WHERE id = p_invoice_id AND ledger_id = p_ledger_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT false, 'Invoice not found'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  IF v_invoice.status = 'void' THEN
    RETURN QUERY SELECT false, 'Invoice is already void'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  IF v_invoice.status = 'paid' THEN
    RETURN QUERY SELECT false, 'Cannot void a fully paid invoice. Issue a credit memo instead.'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  -- If draft, just mark as void (no AR to reverse)
  IF v_invoice.status = 'draft' OR v_invoice.transaction_id IS NULL THEN
    UPDATE invoices
    SET status = 'void',
        voided_at = NOW(),
        void_reason = p_reason
    WHERE id = p_invoice_id;
    
    RETURN QUERY SELECT true, 'Draft invoice voided (no AR to reverse)'::TEXT, NULL::UUID, 0::NUMERIC;
    RETURN;
  END IF;
  
  -- Get required accounts
  v_ar_account_id := get_or_create_ledger_account(p_ledger_id, 'accounts_receivable', 'Accounts Receivable');
  v_revenue_account_id := get_or_create_ledger_account(p_ledger_id, 'revenue', 'Revenue');
  
  IF v_ar_account_id IS NULL OR v_revenue_account_id IS NULL THEN
    RETURN QUERY SELECT false, 'Required accounts not found'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  -- Amount to reverse is the remaining amount_due (unpaid portion)
  v_amount_to_reverse := v_invoice.amount_due / 100.0;
  
  -- Create reversal transaction
  INSERT INTO transactions (
    ledger_id, transaction_type, reference_id, reference_type,
    description, amount, currency, status, reverses, metadata
  ) VALUES (
    p_ledger_id, 'invoice_void', 'VOID-' || v_invoice.invoice_number, 'void',
    'Void: Invoice ' || v_invoice.invoice_number, v_amount_to_reverse,
    v_invoice.currency, 'completed', v_invoice.transaction_id,
    jsonb_build_object(
      'original_invoice_id', v_invoice.id,
      'original_transaction_id', v_invoice.transaction_id,
      'reason', COALESCE(p_reason, 'Voided by user'),
      'original_amount', v_invoice.total_amount / 100.0,
      'amount_paid', v_invoice.amount_paid / 100.0,
      'amount_reversed', v_amount_to_reverse
    )
  )
  RETURNING id INTO v_reversal_tx_id;
  
  -- Create reversal entries: Credit AR (decrease asset), Debit Revenue (decrease income)
  INSERT INTO entries (transaction_id, account_id, entry_type, amount)
  VALUES 
    (v_reversal_tx_id, v_ar_account_id, 'credit', v_amount_to_reverse),
    (v_reversal_tx_id, v_revenue_account_id, 'debit', v_amount_to_reverse);
  
  -- Update invoice status
  UPDATE invoices
  SET status = 'void',
      voided_at = NOW(),
      void_reason = p_reason
  WHERE id = p_invoice_id;
  
  -- Mark original transaction as reversed
  UPDATE transactions
  SET reversed_by = v_reversal_tx_id
  WHERE id = v_invoice.transaction_id;
  
  RETURN QUERY SELECT true, 'Invoice voided and AR reversed'::TEXT, v_reversal_tx_id, v_amount_to_reverse;
  
EXCEPTION WHEN OTHERS THEN
  RETURN QUERY SELECT false, ('Error: ' || SQLERRM)::TEXT, NULL::UUID, NULL::NUMERIC;
END;
$$;

-- ============================================================================
-- 6. Create function to diagnose balance sheet issues
-- ============================================================================

CREATE OR REPLACE FUNCTION diagnose_balance_sheet(p_ledger_id UUID)
RETURNS TABLE(
  category TEXT,
  account_type TEXT,
  account_name TEXT,
  debit_total NUMERIC,
  credit_total NUMERIC,
  net_balance NUMERIC,
  expected_normal TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT
    CASE 
      WHEN a.account_type IN ('cash', 'accounts_receivable', 'inventory', 'prepaid_expense', 'fixed_asset', 'property', 'equipment') THEN 'ASSET'
      WHEN a.account_type IN ('accounts_payable', 'creator_balance', 'payee_balance', 'accrued_expense', 'tax_payable', 'unearned_revenue', 'long_term_debt', 'notes_payable') THEN 'LIABILITY'
      WHEN a.account_type IN ('owner_equity', 'retained_earnings', 'common_stock', 'additional_paid_in_capital') THEN 'EQUITY'
      WHEN a.account_type IN ('revenue', 'platform_revenue') THEN 'REVENUE'
      WHEN a.account_type = 'expense' THEN 'EXPENSE'
      ELSE 'OTHER'
    END as category,
    a.account_type::TEXT,
    a.name::TEXT,
    COALESCE(SUM(CASE WHEN e.entry_type = 'debit' THEN e.amount ELSE 0 END), 0) as debit_total,
    COALESCE(SUM(CASE WHEN e.entry_type = 'credit' THEN e.amount ELSE 0 END), 0) as credit_total,
    COALESCE(SUM(CASE WHEN e.entry_type = 'debit' THEN e.amount ELSE -e.amount END), 0) as net_balance,
    CASE 
      WHEN a.account_type IN ('cash', 'accounts_receivable', 'inventory', 'prepaid_expense', 'fixed_asset', 'property', 'equipment', 'expense') THEN 'DEBIT'
      ELSE 'CREDIT'
    END as expected_normal
  FROM accounts a
  LEFT JOIN entries e ON e.account_id = a.id
  LEFT JOIN transactions t ON e.transaction_id = t.id AND t.status = 'completed'
  WHERE a.ledger_id = p_ledger_id
  GROUP BY a.account_type, a.name, a.id
  ORDER BY category, account_type, a.name;
END;
$$;

-- Grant execute permissions
GRANT EXECUTE ON FUNCTION record_bill_payment_atomic TO authenticated, anon, service_role;
GRANT EXECUTE ON FUNCTION send_invoice_atomic TO authenticated, anon, service_role;
GRANT EXECUTE ON FUNCTION record_invoice_payment_atomic TO authenticated, anon, service_role;
GRANT EXECUTE ON FUNCTION void_invoice_atomic TO authenticated, anon, service_role;
GRANT EXECUTE ON FUNCTION is_valid_uuid TO authenticated, anon, service_role;
GRANT EXECUTE ON FUNCTION diagnose_balance_sheet TO authenticated, anon, service_role;
