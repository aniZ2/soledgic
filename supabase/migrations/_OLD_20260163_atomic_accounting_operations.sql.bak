-- Migration: Atomic Accounting Operations
-- ============================================================================
-- This migration moves critical accounting logic into the database layer
-- to ensure ACID compliance and prevent race conditions.
--
-- Problems solved:
-- 1. AR/AP showing in aging but not balance sheet (ledger-reporting de-sync)
-- 2. Double-void race conditions
-- 3. Net income divergence between P&L and Balance Sheet
-- ============================================================================

-- ============================================================================
-- PART 1: Atomic Invoice Send
-- ============================================================================
-- Ensures invoice status update and AR entry creation happen together

CREATE OR REPLACE FUNCTION send_invoice_atomic(
  p_invoice_id UUID,
  p_ledger_id UUID
)
RETURNS TABLE(
  success BOOLEAN,
  message TEXT,
  transaction_id UUID,
  ar_entry_amount NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_invoice RECORD;
  v_ar_account_id UUID;
  v_revenue_account_id UUID;
  v_transaction_id UUID;
  v_amount_dollars NUMERIC;
BEGIN
  -- Lock the invoice row to prevent concurrent sends
  SELECT * INTO v_invoice
  FROM invoices
  WHERE id = p_invoice_id AND ledger_id = p_ledger_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT false, 'Invoice not found'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  -- Only draft invoices can be sent
  IF v_invoice.status != 'draft' THEN
    RETURN QUERY SELECT false, ('Cannot send invoice with status: ' || v_invoice.status)::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  -- Get or create AR account
  v_ar_account_id := get_or_create_ledger_account(p_ledger_id, 'accounts_receivable', 'Accounts Receivable');
  v_revenue_account_id := get_or_create_ledger_account(p_ledger_id, 'revenue', 'Revenue');
  
  IF v_ar_account_id IS NULL OR v_revenue_account_id IS NULL THEN
    RETURN QUERY SELECT false, 'Failed to create required accounts'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  -- Calculate amount in dollars
  v_amount_dollars := v_invoice.total_amount / 100.0;
  
  -- Create the transaction
  INSERT INTO transactions (
    ledger_id, transaction_type, reference_id, reference_type,
    description, amount, currency, status, metadata
  ) VALUES (
    p_ledger_id, 'invoice', v_invoice.invoice_number, 'invoice',
    'Invoice ' || v_invoice.invoice_number || ' - ' || v_invoice.customer_name,
    v_amount_dollars, v_invoice.currency, 'completed',
    jsonb_build_object(
      'invoice_id', v_invoice.id,
      'customer_id', v_invoice.customer_id,
      'customer_name', v_invoice.customer_name,
      'due_date', v_invoice.due_date
    )
  )
  RETURNING id INTO v_transaction_id;
  
  -- Create double-entry: Debit AR, Credit Revenue
  INSERT INTO entries (transaction_id, account_id, entry_type, amount)
  VALUES 
    (v_transaction_id, v_ar_account_id, 'debit', v_amount_dollars),
    (v_transaction_id, v_revenue_account_id, 'credit', v_amount_dollars);
  
  -- Update invoice status atomically
  UPDATE invoices
  SET status = 'sent',
      sent_at = NOW(),
      transaction_id = v_transaction_id
  WHERE id = p_invoice_id;
  
  RETURN QUERY SELECT true, 'Invoice sent successfully'::TEXT, v_transaction_id, v_amount_dollars;
END;
$$;

COMMENT ON FUNCTION send_invoice_atomic IS 
'Atomically sends an invoice and creates the AR entry. Prevents race conditions with FOR UPDATE lock.';

-- ============================================================================
-- PART 2: Atomic Invoice Void (with Row Locking)
-- ============================================================================
-- Prevents double-void race conditions

CREATE OR REPLACE FUNCTION void_invoice_atomic(
  p_invoice_id UUID,
  p_ledger_id UUID,
  p_reason TEXT DEFAULT NULL
)
RETURNS TABLE(
  success BOOLEAN,
  message TEXT,
  reversal_transaction_id UUID,
  reversed_amount NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_invoice RECORD;
  v_ar_account_id UUID;
  v_revenue_account_id UUID;
  v_reversal_tx_id UUID;
  v_amount_to_reverse NUMERIC;
BEGIN
  -- Lock the invoice row - THIS PREVENTS DOUBLE VOIDS
  SELECT * INTO v_invoice
  FROM invoices
  WHERE id = p_invoice_id AND ledger_id = p_ledger_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT false, 'Invoice not found'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  -- Check current status - after locking!
  IF v_invoice.status = 'void' THEN
    RETURN QUERY SELECT false, 'Invoice is already void'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  IF v_invoice.status = 'paid' THEN
    RETURN QUERY SELECT false, 'Cannot void a fully paid invoice. Issue a credit memo instead.'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  -- If invoice was never sent (draft), just void it without ledger entries
  IF v_invoice.status = 'draft' OR v_invoice.transaction_id IS NULL THEN
    UPDATE invoices
    SET status = 'void',
        voided_at = NOW(),
        void_reason = p_reason
    WHERE id = p_invoice_id;
    
    RETURN QUERY SELECT true, 'Draft invoice voided (no AR to reverse)'::TEXT, NULL::UUID, 0::NUMERIC;
    RETURN;
  END IF;
  
  -- Get accounts
  v_ar_account_id := get_or_create_ledger_account(p_ledger_id, 'accounts_receivable', 'Accounts Receivable');
  v_revenue_account_id := get_or_create_ledger_account(p_ledger_id, 'revenue', 'Revenue');
  
  IF v_ar_account_id IS NULL OR v_revenue_account_id IS NULL THEN
    RETURN QUERY SELECT false, 'Required accounts not found'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  -- Calculate amount to reverse (only the unpaid portion)
  v_amount_to_reverse := v_invoice.amount_due / 100.0;
  
  -- Create reversal transaction
  INSERT INTO transactions (
    ledger_id, transaction_type, reference_id, reference_type,
    description, amount, currency, status, reverses, metadata
  ) VALUES (
    p_ledger_id, 'invoice_void', 'VOID-' || v_invoice.invoice_number, 'void',
    'Void: Invoice ' || v_invoice.invoice_number, v_amount_to_reverse,
    v_invoice.currency, 'completed', v_invoice.transaction_id,
    jsonb_build_object(
      'original_invoice_id', v_invoice.id,
      'original_transaction_id', v_invoice.transaction_id,
      'reason', COALESCE(p_reason, 'Voided by user'),
      'original_amount', v_invoice.total_amount / 100.0,
      'amount_paid', v_invoice.amount_paid / 100.0,
      'amount_reversed', v_amount_to_reverse
    )
  )
  RETURNING id INTO v_reversal_tx_id;
  
  -- Create reversal entries: Credit AR (decrease), Debit Revenue (decrease)
  INSERT INTO entries (transaction_id, account_id, entry_type, amount)
  VALUES 
    (v_reversal_tx_id, v_ar_account_id, 'credit', v_amount_to_reverse),
    (v_reversal_tx_id, v_revenue_account_id, 'debit', v_amount_to_reverse);
  
  -- Update invoice status atomically
  UPDATE invoices
  SET status = 'void',
      voided_at = NOW(),
      void_reason = p_reason
  WHERE id = p_invoice_id;
  
  -- Mark original transaction as reversed
  UPDATE transactions
  SET reversed_by = v_reversal_tx_id
  WHERE id = v_invoice.transaction_id;
  
  RETURN QUERY SELECT true, 'Invoice voided and AR reversed'::TEXT, v_reversal_tx_id, v_amount_to_reverse;
END;
$$;

COMMENT ON FUNCTION void_invoice_atomic IS 
'Atomically voids an invoice and reverses the AR entry. Uses FOR UPDATE to prevent double-void race conditions.';

-- ============================================================================
-- PART 3: Atomic Payment Recording
-- ============================================================================
-- Ensures payment, entries, and invoice update happen together

CREATE OR REPLACE FUNCTION record_invoice_payment_atomic(
  p_invoice_id UUID,
  p_ledger_id UUID,
  p_amount_cents BIGINT,
  p_payment_method TEXT DEFAULT NULL,
  p_payment_date DATE DEFAULT NULL,
  p_reference_id TEXT DEFAULT NULL,
  p_notes TEXT DEFAULT NULL
)
RETURNS TABLE(
  success BOOLEAN,
  message TEXT,
  transaction_id UUID,
  new_status TEXT,
  amount_paid_total BIGINT,
  amount_due_remaining BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_invoice RECORD;
  v_cash_account_id UUID;
  v_ar_account_id UUID;
  v_transaction_id UUID;
  v_amount_dollars NUMERIC;
  v_new_amount_paid BIGINT;
  v_new_amount_due BIGINT;
  v_new_status TEXT;
  v_payment_date DATE;
BEGIN
  -- Lock the invoice row to prevent concurrent payments
  SELECT * INTO v_invoice
  FROM invoices
  WHERE id = p_invoice_id AND ledger_id = p_ledger_id
  FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT false, 'Invoice not found'::TEXT, NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;
  
  -- Validate invoice status
  IF v_invoice.status = 'void' THEN
    RETURN QUERY SELECT false, 'Cannot record payment on void invoice'::TEXT, NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;
  
  IF v_invoice.status = 'draft' THEN
    RETURN QUERY SELECT false, 'Cannot record payment on draft invoice'::TEXT, NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;
  
  IF v_invoice.status = 'paid' THEN
    RETURN QUERY SELECT false, 'Invoice is already fully paid'::TEXT, NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;
  
  -- Validate amount
  IF p_amount_cents <= 0 THEN
    RETURN QUERY SELECT false, 'Payment amount must be positive'::TEXT, NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;
  
  IF p_amount_cents > v_invoice.amount_due THEN
    RETURN QUERY SELECT false, ('Payment amount (' || p_amount_cents || ') exceeds amount due (' || v_invoice.amount_due || ')')::TEXT, 
      NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;
  
  -- Get or create accounts
  v_cash_account_id := get_or_create_ledger_account(p_ledger_id, 'cash', 'Cash / Bank');
  v_ar_account_id := get_or_create_ledger_account(p_ledger_id, 'accounts_receivable', 'Accounts Receivable');
  
  IF v_cash_account_id IS NULL OR v_ar_account_id IS NULL THEN
    RETURN QUERY SELECT false, 'Failed to create required accounts'::TEXT, NULL::UUID, NULL::TEXT, NULL::BIGINT, NULL::BIGINT;
    RETURN;
  END IF;
  
  -- Calculate values
  v_amount_dollars := p_amount_cents / 100.0;
  v_payment_date := COALESCE(p_payment_date, CURRENT_DATE);
  v_new_amount_paid := v_invoice.amount_paid + p_amount_cents;
  v_new_amount_due := v_invoice.total_amount - v_new_amount_paid;
  v_new_status := CASE WHEN v_new_amount_due <= 0 THEN 'paid' ELSE 'partial' END;
  
  -- Create payment transaction: Debit Cash, Credit AR
  INSERT INTO transactions (
    ledger_id, transaction_type, reference_id, reference_type,
    description, amount, currency, status, metadata
  ) VALUES (
    p_ledger_id, 'invoice_payment', p_reference_id, COALESCE(p_payment_method, 'payment'),
    'Payment received: Invoice ' || v_invoice.invoice_number, v_amount_dollars,
    v_invoice.currency, 'completed',
    jsonb_build_object(
      'invoice_id', v_invoice.id,
      'invoice_number', v_invoice.invoice_number,
      'customer_id', v_invoice.customer_id,
      'customer_name', v_invoice.customer_name,
      'payment_method', p_payment_method
    )
  )
  RETURNING id INTO v_transaction_id;
  
  -- Create entries
  INSERT INTO entries (transaction_id, account_id, entry_type, amount)
  VALUES 
    (v_transaction_id, v_cash_account_id, 'debit', v_amount_dollars),
    (v_transaction_id, v_ar_account_id, 'credit', v_amount_dollars);
  
  -- Record in invoice_payments
  INSERT INTO invoice_payments (
    invoice_id, transaction_id, amount, payment_date, 
    payment_method, reference_id, notes
  ) VALUES (
    p_invoice_id, v_transaction_id, p_amount_cents, v_payment_date,
    p_payment_method, p_reference_id, p_notes
  );
  
  -- Update invoice atomically
  UPDATE invoices
  SET amount_paid = v_new_amount_paid,
      amount_due = v_new_amount_due,
      status = v_new_status,
      paid_at = CASE WHEN v_new_status = 'paid' THEN NOW() ELSE NULL END
  WHERE id = p_invoice_id;
  
  RETURN QUERY SELECT true, ('Payment of $' || v_amount_dollars || ' recorded')::TEXT, 
    v_transaction_id, v_new_status, v_new_amount_paid, v_new_amount_due;
END;
$$;

COMMENT ON FUNCTION record_invoice_payment_atomic IS 
'Atomically records a payment on an invoice. Creates ledger entries and updates invoice in single transaction.';

-- ============================================================================
-- PART 4: Atomic Bill Payment
-- ============================================================================

CREATE OR REPLACE FUNCTION record_bill_payment_atomic(
  p_ledger_id UUID,
  p_amount_cents BIGINT,
  p_bill_transaction_id UUID DEFAULT NULL,
  p_vendor_name TEXT DEFAULT NULL,
  p_payment_method TEXT DEFAULT NULL,
  p_reference_id TEXT DEFAULT NULL
)
RETURNS TABLE(
  success BOOLEAN,
  message TEXT,
  transaction_id UUID,
  amount_dollars NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_cash_account_id UUID;
  v_ap_account_id UUID;
  v_transaction_id UUID;
  v_amount_dollars NUMERIC;
  v_description TEXT;
  v_original_bill RECORD;
BEGIN
  -- Validate amount
  IF p_amount_cents <= 0 THEN
    RETURN QUERY SELECT false, 'Payment amount must be positive'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  -- Get or create accounts
  v_cash_account_id := get_or_create_ledger_account(p_ledger_id, 'cash', 'Cash / Bank');
  v_ap_account_id := get_or_create_ledger_account(p_ledger_id, 'accounts_payable', 'Accounts Payable');
  
  IF v_cash_account_id IS NULL OR v_ap_account_id IS NULL THEN
    RETURN QUERY SELECT false, 'Failed to create required accounts'::TEXT, NULL::UUID, NULL::NUMERIC;
    RETURN;
  END IF;
  
  v_amount_dollars := p_amount_cents / 100.0;
  
  -- Build description
  v_description := 'Bill payment';
  IF p_bill_transaction_id IS NOT NULL THEN
    SELECT description, merchant_name INTO v_original_bill
    FROM transactions
    WHERE id = p_bill_transaction_id AND ledger_id = p_ledger_id;
    
    IF FOUND AND v_original_bill.description IS NOT NULL THEN
      v_description := 'Payment: ' || v_original_bill.description;
    END IF;
  ELSIF p_vendor_name IS NOT NULL THEN
    v_description := 'Payment to ' || p_vendor_name;
  END IF;
  
  -- Create payment transaction: Debit AP (reduce liability), Credit Cash (reduce asset)
  INSERT INTO transactions (
    ledger_id, transaction_type, reference_id, reference_type,
    description, amount, currency, status, merchant_name, metadata
  ) VALUES (
    p_ledger_id, 'bill_payment', p_reference_id, COALESCE(p_payment_method, 'payment'),
    v_description, v_amount_dollars, 'USD', 'completed', p_vendor_name,
    jsonb_build_object(
      'original_bill_id', p_bill_transaction_id,
      'payment_method', p_payment_method
    )
  )
  RETURNING id INTO v_transaction_id;
  
  -- Create entries: Debit AP, Credit Cash
  INSERT INTO entries (transaction_id, account_id, entry_type, amount)
  VALUES 
    (v_transaction_id, v_ap_account_id, 'debit', v_amount_dollars),
    (v_transaction_id, v_cash_account_id, 'credit', v_amount_dollars);
  
  RETURN QUERY SELECT true, ('Bill payment of $' || v_amount_dollars || ' recorded')::TEXT, 
    v_transaction_id, v_amount_dollars;
END;
$$;

COMMENT ON FUNCTION record_bill_payment_atomic IS 
'Atomically records a bill payment with proper double-entry bookkeeping.';

-- ============================================================================
-- PART 5: Ledger-Based AR Aging View
-- ============================================================================
-- This ensures AR aging matches the balance sheet by querying the ledger

CREATE OR REPLACE VIEW v_ar_aging_from_ledger AS
WITH ar_balances AS (
  -- Get outstanding AR by invoice from ledger entries
  SELECT 
    i.id as invoice_id,
    i.ledger_id,
    i.invoice_number,
    i.customer_name,
    i.customer_id,
    i.due_date,
    i.issue_date,
    i.currency,
    i.status,
    -- Calculate AR balance from entries (debits - credits on AR account for this invoice's transactions)
    COALESCE(
      (SELECT SUM(
        CASE WHEN e.entry_type = 'debit' THEN e.amount ELSE -e.amount END
      )
      FROM entries e
      JOIN transactions t ON e.transaction_id = t.id
      JOIN accounts a ON e.account_id = a.id
      WHERE a.ledger_id = i.ledger_id
        AND a.account_type = 'accounts_receivable'
        AND t.status = 'completed'
        AND (
          t.id = i.transaction_id 
          OR t.metadata->>'invoice_id' = i.id::text
          OR t.metadata->>'original_invoice_id' = i.id::text
        )
      ), 0
    ) as ar_balance,
    CURRENT_DATE - i.due_date as days_overdue
  FROM invoices i
  WHERE i.status IN ('sent', 'partial')
)
SELECT 
  invoice_id,
  ledger_id,
  invoice_number,
  customer_name,
  customer_id,
  due_date,
  issue_date,
  currency,
  status,
  ar_balance,
  days_overdue,
  CASE 
    WHEN days_overdue <= 0 THEN 'current'
    WHEN days_overdue <= 30 THEN '1-30'
    WHEN days_overdue <= 60 THEN '31-60'
    WHEN days_overdue <= 90 THEN '61-90'
    ELSE 'over_90'
  END as aging_bucket
FROM ar_balances
WHERE ar_balance > 0.005;  -- Only show invoices with outstanding balance

-- ============================================================================
-- PART 6: Ledger-Based AP Aging View
-- ============================================================================

CREATE OR REPLACE VIEW v_ap_aging_from_ledger AS
WITH ap_transactions AS (
  -- Get unpaid bills from ledger
  SELECT 
    t.id as transaction_id,
    t.ledger_id,
    t.description,
    t.merchant_name as vendor_name,
    t.metadata->>'vendor_id' as vendor_id,
    (t.metadata->>'due_date')::date as due_date,
    t.created_at::date as bill_date,
    t.currency,
    -- Calculate AP balance from entries
    COALESCE(
      (SELECT SUM(
        CASE WHEN e.entry_type = 'credit' THEN e.amount ELSE -e.amount END
      )
      FROM entries e
      JOIN accounts a ON e.account_id = a.id
      WHERE a.ledger_id = t.ledger_id
        AND a.account_type = 'accounts_payable'
        AND e.transaction_id IN (
          SELECT t2.id FROM transactions t2 
          WHERE t2.ledger_id = t.ledger_id 
            AND t2.status = 'completed'
            AND (
              t2.id = t.id 
              OR t2.metadata->>'original_bill_id' = t.id::text
            )
        )
      ), 0
    ) as ap_balance
  FROM transactions t
  WHERE t.transaction_type = 'bill'
    AND t.status = 'completed'
    AND (t.metadata->>'paid')::boolean IS NOT TRUE
)
SELECT 
  transaction_id,
  ledger_id,
  description,
  vendor_name,
  vendor_id,
  due_date,
  bill_date,
  currency,
  ap_balance,
  COALESCE(CURRENT_DATE - due_date, 0) as days_overdue,
  CASE 
    WHEN CURRENT_DATE - due_date <= 0 THEN 'current'
    WHEN CURRENT_DATE - due_date <= 30 THEN '1-30'
    WHEN CURRENT_DATE - due_date <= 60 THEN '31-60'
    WHEN CURRENT_DATE - due_date <= 90 THEN '61-90'
    ELSE 'over_90'
  END as aging_bucket
FROM ap_transactions
WHERE ap_balance > 0.005;

-- ============================================================================
-- PART 7: Recalculate all balances after atomic functions are in place
-- ============================================================================

SELECT recalculate_all_balances();

-- ============================================================================
-- PART 8: Verify ledger integrity
-- ============================================================================

DO $$
DECLARE
  v_ledger RECORD;
  v_debits NUMERIC;
  v_credits NUMERIC;
  v_diff NUMERIC;
BEGIN
  FOR v_ledger IN SELECT DISTINCT ledger_id FROM transactions LOOP
    SELECT 
      COALESCE(SUM(CASE WHEN e.entry_type = 'debit' THEN e.amount ELSE 0 END), 0),
      COALESCE(SUM(CASE WHEN e.entry_type = 'credit' THEN e.amount ELSE 0 END), 0)
    INTO v_debits, v_credits
    FROM entries e
    JOIN transactions t ON e.transaction_id = t.id
    WHERE t.ledger_id = v_ledger.ledger_id AND t.status = 'completed';
    
    v_diff := ABS(v_debits - v_credits);
    
    IF v_diff > 0.01 THEN
      RAISE WARNING 'Ledger % is UNBALANCED: debits=%, credits=%, diff=%', 
        v_ledger.ledger_id, v_debits, v_credits, v_diff;
    ELSE
      RAISE NOTICE 'Ledger % is balanced (debits=credits=%)', v_ledger.ledger_id, v_debits;
    END IF;
  END LOOP;
END;
$$;
